skol! "sim" 0.4

#TkInvalid: -1
#TkLBrace:   1
#TkRBrace:   2
#TkLBracket: 3
#TkRBracket: 4
#TkColon:    5
#TkComma:    6
#TkString:   7
#TkNumber:   8

@Token(
  Kind/int
)

@StringToken(
  Kind/int
  Content/str
)

@NumberToken(
  Kind/int
  Value/int
)

%Source: "{\"name\":\"John\",\"age\":24}"
%Pos: 0

$IsEOF/bool(
  >eq! Pos str_len! Source
)

$IsDigit/bool c/char(
  >and! or! gt_c! c '0' eq! c '0' or! lt_c! c '9' eq! c '9'
)

$NextChar/char(
  %c: char_at! Source Pos
  %Pos: add_i! Pos 1
  >c
)

$NextString/Token(
  %StringLit: ""

  %c: NextChar!

  *and! not! eq! c '"' not! IsEOF!(
    %StringLit: char_append! StringLit c
    %c: NextChar!
  )

  >@StringToken TkString StringLit
)

$NextNumber/Token(
  %NumberLit: 0
  *not! IsEOF! (
    %NumberLit: add_i! mul_i! NumberLit 10 ctoi! sub_c! c '0'
    %c: NextChar!
    ?not! IsDigit! c (
      %Pos: sub_i! Pos 1
      >@NumberToken TkNumber NumberLit
    )
  )
  >@NumberToken TkNumber NumberLit
)

$NextToken/Token(
  ?IsEOF!(>@Token TkInvalid)

  %c: NextChar!

  ?eq! c '{' (>@Token TkLBrace)
  ?eq! c '}' (>@Token TkRBrace)
  ?eq! c '[' (>@Token TkLBracket)
  ?eq! c ']' (>@Token TkRBracket)
  ?eq! c ':' (>@Token TkColon)
  ?eq! c ',' (>@Token TkComma)

  ?IsDigit! c (>NextNumber!)
  ?eq! c '"' (>NextString!)

  print! concat! "Illegal character: " to_str! c

  >@Token TkInvalid
)

// skol doesn't have custom types, so we're just pretending to return a parsed
// value. Check issue #19
#ValInvalid: -1
#ValNumber:   1
#ValString:   2
#ValArray:    3
#ValObject:   4

@Value(
  Kind/int
)

@NumberValue(
  Kind/int
  Value/int
)

@StringValue(
  Kind/int
  Value/str
)

$NextValue/Value?
$NextValueFrom/Value Tok/Token?

$PrintValue Val/Value(
  ?eq! Val#Kind ValString (
    %SVal: Val#@StringValue
    print! SVal#Value
  )
  ?eq! Val#Kind ValNumber (
    %NVal: Val#@NumberValue
    print! to_str! NVal#Value
  )
)

$NextObject/Value(
  **( // infinite loop: either reach RBrace or EOF
    %Tok: NextToken!
    ? eq! Tok#Kind TkRBrace
      (>@Value ValObject)
    :?not! eq! Tok#Kind TkString (
      print! "Expected a string"
      >@Value ValInvalid
    )
    %Key: StringLit
    print! "Key: "
    print! Key

    %Tok: NextToken!
    ?not! eq! Tok#Kind TkColon (
      print! "Expected a colon"
      >@Value ValInvalid
    )

    %Value: NextValue!
    ?eq! Value#Kind ValInvalid (
      print! "Got invalid value"
      >@Value ValInvalid
    )
    print! "Value: "
    PrintValue! Value

    %Tok: NextToken!
    ? eq! Tok#Kind TkRBrace
      (>@Value ValObject)
    :?not! eq! Tok#Kind TkComma (
      print! "Expected comma"
      >@Value ValInvalid
    )
  )
  >@Value ValObject // theoretically never reached
)

$NextArray/Value(
  **( // infinite loop; refer to NextObject
    %Tok: NextToken!
    ?eq! Tok TkRBracket (>@Value ValArray)

    %Value: NextValueFrom! Tok
    ?eq! Value ValInvalid (>@Value ValInvalid)

    print! concat! "Array entry: " to_str! Value
  )
  >@Value ValArray // again, theoretically never reached
)

$NextValueFrom/Value Tok/Token(
  ?eq! Tok#Kind TkLBrace
    (>NextObject!)
  ?eq! Tok#Kind TkLBracket
    (>NextArray!)
  ?eq! Tok#Kind TkString
    (>@StringValue ValString Tok#Content)
  ?eq! Tok#Kind TkNumber
    (>@NumberValue ValNumber Tok#Value)

  >@Value ValInvalid
)

$NextValue/Value(
  %Tok: NextToken!
  >NextValueFrom! Tok
)

$Main(
  to_str! NextValue!
)

Main!
